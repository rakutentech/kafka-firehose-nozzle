// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: ext.go
// DO NOT EDIT!

package ext

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/cloudfoundry/sonde-go/events"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *Envelope) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Envelope) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Origin != nil {
		if true {
			buf.WriteString(`"origin":`)
			fflib.WriteJsonString(buf, string(*mj.Origin))
			buf.WriteByte(',')
		}
	}
	if mj.EventType != nil {
		if true {
			buf.WriteString(`"eventType":`)
			fflib.FormatBits2(buf, uint64(*mj.EventType), 10, *mj.EventType < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Timestamp != nil {
		if true {
			buf.WriteString(`"timestamp":`)
			fflib.FormatBits2(buf, uint64(*mj.Timestamp), 10, *mj.Timestamp < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Deployment != nil {
		if true {
			buf.WriteString(`"deployment":`)
			fflib.WriteJsonString(buf, string(*mj.Deployment))
			buf.WriteByte(',')
		}
	}
	if mj.Job != nil {
		if true {
			buf.WriteString(`"job":`)
			fflib.WriteJsonString(buf, string(*mj.Job))
			buf.WriteByte(',')
		}
	}
	if mj.Index != nil {
		if true {
			buf.WriteString(`"index":`)
			fflib.WriteJsonString(buf, string(*mj.Index))
			buf.WriteByte(',')
		}
	}
	if mj.Ip != nil {
		if true {
			buf.WriteString(`"ip":`)
			fflib.WriteJsonString(buf, string(*mj.Ip))
			buf.WriteByte(',')
		}
	}
	if len(mj.Tags) != 0 {
		if mj.Tags == nil {
			buf.WriteString(`"tags":null`)
		} else {
			buf.WriteString(`"tags":{ `)
			for key, value := range mj.Tags {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	if mj.HttpStartStop != nil {
		if true {
			buf.WriteString(`"httpStartStop":`)

			{

				err = mj.HttpStartStop.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.LogMessage != nil {
		if true {
			buf.WriteString(`"logMessage":`)

			{

				err = mj.LogMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ValueMetric != nil {
		if true {
			buf.WriteString(`"valueMetric":`)

			{

				err = mj.ValueMetric.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.CounterEvent != nil {
		if true {
			buf.WriteString(`"counterEvent":`)

			{

				err = mj.CounterEvent.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Error != nil {
		if true {
			buf.WriteString(`"error":`)

			{

				err = mj.Error.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ContainerMetric != nil {
		if true {
			buf.WriteString(`"containerMetric":`)

			{

				err = mj.ContainerMetric.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.AppGuid) != 0 {
		buf.WriteString(`"app_guid":`)
		fflib.WriteJsonString(buf, string(mj.AppGuid))
		buf.WriteByte(',')
	}
	if len(mj.AppName) != 0 {
		buf.WriteString(`"app_name":`)
		fflib.WriteJsonString(buf, string(mj.AppName))
		buf.WriteByte(',')
	}
	if len(mj.SpaceGuid) != 0 {
		buf.WriteString(`"space_guid":`)
		fflib.WriteJsonString(buf, string(mj.SpaceGuid))
		buf.WriteByte(',')
	}
	if len(mj.SpaceName) != 0 {
		buf.WriteString(`"space_name":`)
		fflib.WriteJsonString(buf, string(mj.SpaceName))
		buf.WriteByte(',')
	}
	if len(mj.OrgGuid) != 0 {
		buf.WriteString(`"org_guid":`)
		fflib.WriteJsonString(buf, string(mj.OrgGuid))
		buf.WriteByte(',')
	}
	if len(mj.OrgName) != 0 {
		buf.WriteString(`"org_name":`)
		fflib.WriteJsonString(buf, string(mj.OrgName))
		buf.WriteByte(',')
	}
	if len(mj.InstanceID) != 0 {
		buf.WriteString(`"instance_guid":`)
		fflib.WriteJsonString(buf, string(mj.InstanceID))
		buf.WriteByte(',')
	}
	if mj.InstanceIdx != 0 {
		buf.WriteString(`"instance_idx":`)
		fflib.FormatBits2(buf, uint64(mj.InstanceIdx), 10, mj.InstanceIdx < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Envelopebase = iota
	ffj_t_Envelopeno_such_key

	ffj_t_Envelope_Origin

	ffj_t_Envelope_EventType

	ffj_t_Envelope_Timestamp

	ffj_t_Envelope_Deployment

	ffj_t_Envelope_Job

	ffj_t_Envelope_Index

	ffj_t_Envelope_Ip

	ffj_t_Envelope_Tags

	ffj_t_Envelope_HttpStartStop

	ffj_t_Envelope_LogMessage

	ffj_t_Envelope_ValueMetric

	ffj_t_Envelope_CounterEvent

	ffj_t_Envelope_Error

	ffj_t_Envelope_ContainerMetric

	ffj_t_Envelope_AppGuid

	ffj_t_Envelope_AppName

	ffj_t_Envelope_SpaceGuid

	ffj_t_Envelope_SpaceName

	ffj_t_Envelope_OrgGuid

	ffj_t_Envelope_OrgName

	ffj_t_Envelope_InstanceID

	ffj_t_Envelope_InstanceIdx
)

var ffj_key_Envelope_Origin = []byte("origin")

var ffj_key_Envelope_EventType = []byte("eventType")

var ffj_key_Envelope_Timestamp = []byte("timestamp")

var ffj_key_Envelope_Deployment = []byte("deployment")

var ffj_key_Envelope_Job = []byte("job")

var ffj_key_Envelope_Index = []byte("index")

var ffj_key_Envelope_Ip = []byte("ip")

var ffj_key_Envelope_Tags = []byte("tags")

var ffj_key_Envelope_HttpStartStop = []byte("httpStartStop")

var ffj_key_Envelope_LogMessage = []byte("logMessage")

var ffj_key_Envelope_ValueMetric = []byte("valueMetric")

var ffj_key_Envelope_CounterEvent = []byte("counterEvent")

var ffj_key_Envelope_Error = []byte("error")

var ffj_key_Envelope_ContainerMetric = []byte("containerMetric")

var ffj_key_Envelope_AppGuid = []byte("app_guid")

var ffj_key_Envelope_AppName = []byte("app_name")

var ffj_key_Envelope_SpaceGuid = []byte("space_guid")

var ffj_key_Envelope_SpaceName = []byte("space_name")

var ffj_key_Envelope_OrgGuid = []byte("org_guid")

var ffj_key_Envelope_OrgName = []byte("org_name")

var ffj_key_Envelope_InstanceID = []byte("instance_guid")

var ffj_key_Envelope_InstanceIdx = []byte("instance_idx")

func (uj *Envelope) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Envelope) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Envelopebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Envelopeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Envelope_AppGuid, kn) {
						currentKey = ffj_t_Envelope_AppGuid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_AppName, kn) {
						currentKey = ffj_t_Envelope_AppName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_Envelope_CounterEvent, kn) {
						currentKey = ffj_t_Envelope_CounterEvent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_ContainerMetric, kn) {
						currentKey = ffj_t_Envelope_ContainerMetric
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Envelope_Deployment, kn) {
						currentKey = ffj_t_Envelope_Deployment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Envelope_EventType, kn) {
						currentKey = ffj_t_Envelope_EventType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_Error, kn) {
						currentKey = ffj_t_Envelope_Error
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Envelope_HttpStartStop, kn) {
						currentKey = ffj_t_Envelope_HttpStartStop
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Envelope_Index, kn) {
						currentKey = ffj_t_Envelope_Index
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_Ip, kn) {
						currentKey = ffj_t_Envelope_Ip
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_InstanceID, kn) {
						currentKey = ffj_t_Envelope_InstanceID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_InstanceIdx, kn) {
						currentKey = ffj_t_Envelope_InstanceIdx
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'j':

					if bytes.Equal(ffj_key_Envelope_Job, kn) {
						currentKey = ffj_t_Envelope_Job
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Envelope_LogMessage, kn) {
						currentKey = ffj_t_Envelope_LogMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_Envelope_Origin, kn) {
						currentKey = ffj_t_Envelope_Origin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_OrgGuid, kn) {
						currentKey = ffj_t_Envelope_OrgGuid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_OrgName, kn) {
						currentKey = ffj_t_Envelope_OrgName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Envelope_SpaceGuid, kn) {
						currentKey = ffj_t_Envelope_SpaceGuid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_SpaceName, kn) {
						currentKey = ffj_t_Envelope_SpaceName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Envelope_Timestamp, kn) {
						currentKey = ffj_t_Envelope_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Envelope_Tags, kn) {
						currentKey = ffj_t_Envelope_Tags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Envelope_ValueMetric, kn) {
						currentKey = ffj_t_Envelope_ValueMetric
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Envelope_InstanceIdx, kn) {
					currentKey = ffj_t_Envelope_InstanceIdx
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Envelope_InstanceID, kn) {
					currentKey = ffj_t_Envelope_InstanceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Envelope_OrgName, kn) {
					currentKey = ffj_t_Envelope_OrgName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Envelope_OrgGuid, kn) {
					currentKey = ffj_t_Envelope_OrgGuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Envelope_SpaceName, kn) {
					currentKey = ffj_t_Envelope_SpaceName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Envelope_SpaceGuid, kn) {
					currentKey = ffj_t_Envelope_SpaceGuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Envelope_AppName, kn) {
					currentKey = ffj_t_Envelope_AppName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Envelope_AppGuid, kn) {
					currentKey = ffj_t_Envelope_AppGuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_ContainerMetric, kn) {
					currentKey = ffj_t_Envelope_ContainerMetric
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_Error, kn) {
					currentKey = ffj_t_Envelope_Error
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_CounterEvent, kn) {
					currentKey = ffj_t_Envelope_CounterEvent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_ValueMetric, kn) {
					currentKey = ffj_t_Envelope_ValueMetric
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Envelope_LogMessage, kn) {
					currentKey = ffj_t_Envelope_LogMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Envelope_HttpStartStop, kn) {
					currentKey = ffj_t_Envelope_HttpStartStop
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Envelope_Tags, kn) {
					currentKey = ffj_t_Envelope_Tags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_Ip, kn) {
					currentKey = ffj_t_Envelope_Ip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_Index, kn) {
					currentKey = ffj_t_Envelope_Index
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_Job, kn) {
					currentKey = ffj_t_Envelope_Job
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_Deployment, kn) {
					currentKey = ffj_t_Envelope_Deployment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Envelope_Timestamp, kn) {
					currentKey = ffj_t_Envelope_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_EventType, kn) {
					currentKey = ffj_t_Envelope_EventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Envelope_Origin, kn) {
					currentKey = ffj_t_Envelope_Origin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Envelopeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Envelope_Origin:
					goto handle_Origin

				case ffj_t_Envelope_EventType:
					goto handle_EventType

				case ffj_t_Envelope_Timestamp:
					goto handle_Timestamp

				case ffj_t_Envelope_Deployment:
					goto handle_Deployment

				case ffj_t_Envelope_Job:
					goto handle_Job

				case ffj_t_Envelope_Index:
					goto handle_Index

				case ffj_t_Envelope_Ip:
					goto handle_Ip

				case ffj_t_Envelope_Tags:
					goto handle_Tags

				case ffj_t_Envelope_HttpStartStop:
					goto handle_HttpStartStop

				case ffj_t_Envelope_LogMessage:
					goto handle_LogMessage

				case ffj_t_Envelope_ValueMetric:
					goto handle_ValueMetric

				case ffj_t_Envelope_CounterEvent:
					goto handle_CounterEvent

				case ffj_t_Envelope_Error:
					goto handle_Error

				case ffj_t_Envelope_ContainerMetric:
					goto handle_ContainerMetric

				case ffj_t_Envelope_AppGuid:
					goto handle_AppGuid

				case ffj_t_Envelope_AppName:
					goto handle_AppName

				case ffj_t_Envelope_SpaceGuid:
					goto handle_SpaceGuid

				case ffj_t_Envelope_SpaceName:
					goto handle_SpaceName

				case ffj_t_Envelope_OrgGuid:
					goto handle_OrgGuid

				case ffj_t_Envelope_OrgName:
					goto handle_OrgName

				case ffj_t_Envelope_InstanceID:
					goto handle_InstanceID

				case ffj_t_Envelope_InstanceIdx:
					goto handle_InstanceIdx

				case ffj_t_Envelopeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Origin:

	/* handler: uj.Origin type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Origin = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Origin = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EventType:

	/* handler: uj.EventType type=events.Envelope_EventType kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.EventType = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.EventType == nil {
			uj.EventType = new(events.Envelope_EventType)
		}

		err = uj.EventType.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: uj.Timestamp type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Timestamp = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.Timestamp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deployment:

	/* handler: uj.Deployment type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Deployment = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Deployment = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Job:

	/* handler: uj.Job type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Job = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Job = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Index:

	/* handler: uj.Index type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Index = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Index = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip:

	/* handler: uj.Ip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Ip = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Ip = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tags:

	/* handler: uj.Tags type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Tags = nil
		} else {

			uj.Tags = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__Tags string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__Tags type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__Tags = string(string(outBuf))

					}
				}

				uj.Tags[k] = tmp_uj__Tags

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HttpStartStop:

	/* handler: uj.HttpStartStop type=events.HttpStartStop kind=struct quoted=false*/

	{
		/* Falling back. type=events.HttpStartStop kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.HttpStartStop)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LogMessage:

	/* handler: uj.LogMessage type=events.LogMessage kind=struct quoted=false*/

	{
		/* Falling back. type=events.LogMessage kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.LogMessage)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ValueMetric:

	/* handler: uj.ValueMetric type=events.ValueMetric kind=struct quoted=false*/

	{
		/* Falling back. type=events.ValueMetric kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.ValueMetric)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CounterEvent:

	/* handler: uj.CounterEvent type=events.CounterEvent kind=struct quoted=false*/

	{
		/* Falling back. type=events.CounterEvent kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.CounterEvent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Error:

	/* handler: uj.Error type=events.Error kind=struct quoted=false*/

	{
		/* Falling back. type=events.Error kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Error)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerMetric:

	/* handler: uj.ContainerMetric type=events.ContainerMetric kind=struct quoted=false*/

	{
		/* Falling back. type=events.ContainerMetric kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.ContainerMetric)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppGuid:

	/* handler: uj.AppGuid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppGuid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppName:

	/* handler: uj.AppName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SpaceGuid:

	/* handler: uj.SpaceGuid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SpaceGuid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SpaceName:

	/* handler: uj.SpaceName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SpaceName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrgGuid:

	/* handler: uj.OrgGuid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OrgGuid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrgName:

	/* handler: uj.OrgName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OrgName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstanceID:

	/* handler: uj.InstanceID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.InstanceID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstanceIdx:

	/* handler: uj.InstanceIdx type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InstanceIdx = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ExtraContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ExtraContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.AppGuid) != 0 {
		buf.WriteString(`"app_guid":`)
		fflib.WriteJsonString(buf, string(mj.AppGuid))
		buf.WriteByte(',')
	}
	if len(mj.AppName) != 0 {
		buf.WriteString(`"app_name":`)
		fflib.WriteJsonString(buf, string(mj.AppName))
		buf.WriteByte(',')
	}
	if len(mj.SpaceGuid) != 0 {
		buf.WriteString(`"space_guid":`)
		fflib.WriteJsonString(buf, string(mj.SpaceGuid))
		buf.WriteByte(',')
	}
	if len(mj.SpaceName) != 0 {
		buf.WriteString(`"space_name":`)
		fflib.WriteJsonString(buf, string(mj.SpaceName))
		buf.WriteByte(',')
	}
	if len(mj.OrgGuid) != 0 {
		buf.WriteString(`"org_guid":`)
		fflib.WriteJsonString(buf, string(mj.OrgGuid))
		buf.WriteByte(',')
	}
	if len(mj.OrgName) != 0 {
		buf.WriteString(`"org_name":`)
		fflib.WriteJsonString(buf, string(mj.OrgName))
		buf.WriteByte(',')
	}
	if len(mj.InstanceID) != 0 {
		buf.WriteString(`"instance_guid":`)
		fflib.WriteJsonString(buf, string(mj.InstanceID))
		buf.WriteByte(',')
	}
	if mj.InstanceIdx != 0 {
		buf.WriteString(`"instance_idx":`)
		fflib.FormatBits2(buf, uint64(mj.InstanceIdx), 10, mj.InstanceIdx < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ExtraContentbase = iota
	ffj_t_ExtraContentno_such_key

	ffj_t_ExtraContent_AppGuid

	ffj_t_ExtraContent_AppName

	ffj_t_ExtraContent_SpaceGuid

	ffj_t_ExtraContent_SpaceName

	ffj_t_ExtraContent_OrgGuid

	ffj_t_ExtraContent_OrgName

	ffj_t_ExtraContent_InstanceID

	ffj_t_ExtraContent_InstanceIdx
)

var ffj_key_ExtraContent_AppGuid = []byte("app_guid")

var ffj_key_ExtraContent_AppName = []byte("app_name")

var ffj_key_ExtraContent_SpaceGuid = []byte("space_guid")

var ffj_key_ExtraContent_SpaceName = []byte("space_name")

var ffj_key_ExtraContent_OrgGuid = []byte("org_guid")

var ffj_key_ExtraContent_OrgName = []byte("org_name")

var ffj_key_ExtraContent_InstanceID = []byte("instance_guid")

var ffj_key_ExtraContent_InstanceIdx = []byte("instance_idx")

func (uj *ExtraContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ExtraContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ExtraContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ExtraContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ExtraContent_AppGuid, kn) {
						currentKey = ffj_t_ExtraContent_AppGuid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ExtraContent_AppName, kn) {
						currentKey = ffj_t_ExtraContent_AppName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ExtraContent_InstanceID, kn) {
						currentKey = ffj_t_ExtraContent_InstanceID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ExtraContent_InstanceIdx, kn) {
						currentKey = ffj_t_ExtraContent_InstanceIdx
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_ExtraContent_OrgGuid, kn) {
						currentKey = ffj_t_ExtraContent_OrgGuid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ExtraContent_OrgName, kn) {
						currentKey = ffj_t_ExtraContent_OrgName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ExtraContent_SpaceGuid, kn) {
						currentKey = ffj_t_ExtraContent_SpaceGuid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ExtraContent_SpaceName, kn) {
						currentKey = ffj_t_ExtraContent_SpaceName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ExtraContent_InstanceIdx, kn) {
					currentKey = ffj_t_ExtraContent_InstanceIdx
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExtraContent_InstanceID, kn) {
					currentKey = ffj_t_ExtraContent_InstanceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ExtraContent_OrgName, kn) {
					currentKey = ffj_t_ExtraContent_OrgName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ExtraContent_OrgGuid, kn) {
					currentKey = ffj_t_ExtraContent_OrgGuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExtraContent_SpaceName, kn) {
					currentKey = ffj_t_ExtraContent_SpaceName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExtraContent_SpaceGuid, kn) {
					currentKey = ffj_t_ExtraContent_SpaceGuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ExtraContent_AppName, kn) {
					currentKey = ffj_t_ExtraContent_AppName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ExtraContent_AppGuid, kn) {
					currentKey = ffj_t_ExtraContent_AppGuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ExtraContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ExtraContent_AppGuid:
					goto handle_AppGuid

				case ffj_t_ExtraContent_AppName:
					goto handle_AppName

				case ffj_t_ExtraContent_SpaceGuid:
					goto handle_SpaceGuid

				case ffj_t_ExtraContent_SpaceName:
					goto handle_SpaceName

				case ffj_t_ExtraContent_OrgGuid:
					goto handle_OrgGuid

				case ffj_t_ExtraContent_OrgName:
					goto handle_OrgName

				case ffj_t_ExtraContent_InstanceID:
					goto handle_InstanceID

				case ffj_t_ExtraContent_InstanceIdx:
					goto handle_InstanceIdx

				case ffj_t_ExtraContentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AppGuid:

	/* handler: uj.AppGuid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppGuid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppName:

	/* handler: uj.AppName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SpaceGuid:

	/* handler: uj.SpaceGuid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SpaceGuid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SpaceName:

	/* handler: uj.SpaceName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SpaceName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrgGuid:

	/* handler: uj.OrgGuid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OrgGuid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrgName:

	/* handler: uj.OrgName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OrgName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstanceID:

	/* handler: uj.InstanceID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.InstanceID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstanceIdx:

	/* handler: uj.InstanceIdx type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InstanceIdx = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
